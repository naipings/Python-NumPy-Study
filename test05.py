# Fancy indexing 花式索引
# 花式索引是一个 NumPy术语，它指的是利用整数数组进行索引
import numpy as np

arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
print(arr)
'''
[[0. 0. 0. 0.]
 [1. 1. 1. 1.]
 [2. 2. 2. 2.]
 [3. 3. 3. 3.]
 [4. 4. 4. 4.]
 [5. 5. 5. 5.]
 [6. 6. 6. 6.]
 [7. 7. 7. 7.]]
'''

# 为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或 ndarray 即可：
print(arr[[4, 3, 0, 6]])
'''
[[4. 4. 4. 4.]
 [3. 3. 3. 3.]
 [0. 0. 0. 0.]
 [6. 6. 6. 6.]]
'''

# 这段代码确实达到我们的要求了！使用负数索引将会从末尾开始选取行
print(arr[[-3, -5, -7]])
'''
[[5. 5. 5. 5.]
 [3. 3. 3. 3.]
 [1. 1. 1. 1.]]
'''

# 一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组
arr = np.arange(32).reshape((8, 4))
print(arr)
'''
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]
 [16 17 18 19]
 [20 21 22 23]
 [24 25 26 27]
 [28 29 30 31]]
'''

print(arr[[1, 5, 7, 2], [0, 3, 1, 2]])
'''
[ 4 23 29 10]

由结果可知：
最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。
无论数组是多少维的，花式索引总是一维的。
'''

# 这个花式索引的行为可能会跟某些用户的预期不一样，选取矩阵的行列子集应该是矩形区域的形式才对。下面是得到该结果的一个办法：
print( arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]])
'''
[[ 4  7  5  6]
 [20 23 21 22]
 [28 31 29 30]
 [ 8 11  9 10]]
'''

# 记住，花式索引跟切片不一样，它总是将数据复制到新数组中。